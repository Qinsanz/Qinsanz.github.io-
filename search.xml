<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA基础]]></title>
    <url>%2F2020%2F01%2F11%2FJAVA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[##常用API（Application Programming Interface,应用程序编程接口）** ####1、java.util.Scanner 键盘输入 Scanner sc=new Scanner(System.in); int a=sc.nextInt();//数字输入 String str=sc.next();//字符串输入 System.out.printIn(“您输入的数字为：”+a+” 输入的字符串为：”+str);//控制台输出 ####2、匿名对象 /* 创建对象标准格式： 类名称 对象名=new 类名称(); 匿名对象就是只有右边的对象，没有左边的名字和赋值运算符：new 类名称() 注：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象，建议如果只有一个对象只需要使用唯一一次，就可以用匿名对象。 */ int num=new Scanner(System.in).nextInt(); System.out.printIn(“您输入的数字为：”+num); //匿名对象当做方法参数进行传参 方法名(new Scanner(System.in).nextInt()); //匿名对象当做返回值 （Int） return new Scanner(System.in).nextInt(); ####3、java.util.Random 随机数 int num=r.nextInt(n);//范围 [0,n),左闭右开区间; int result = r.nextInt(n)+1//范围[1,n); ####4、对象数组 /* 数组一旦创建，程序运行期间数组长度不可改变。 java.util.ArrayList,ArrayList等集合创建后长度可变,”“泛型 泛型只能是引用类型，不能是基本类型，集合里保存的都是地址值，基本数据类型没有地址值，存基本类型值需要使用包装对应包装类 基本类型 包装类（引用类型，包装类全都位于java.lang包下） 整型： byte Byte 1个字节 8位 -128~127 short Short 2个字节 16位 (-2^15~2^15-1) int Integer 4个字节 32位 (-2^31~2^31-1) long Long 8个字节 64位 (-2^63~2^63-1) 浮点型： float Float 4个字节 32位 (-2^31~2^31-1) double Double 8个字节 64位 (-2^63~2^63-1) 注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。 Char类型： char Character 2个字节 16位 (-2^15~2^15-1) Boolean类型： boolean Boolean （true or false）（并未指明是多少字节 1字节 1位 4字节） 从JDK 1.5+开始自动装箱、拆箱 */ ArrayList list =new ArrayList&lt;&gt;();//JDK1.7后，右边&lt;&gt;可以省略类型 System.out.printIn(list);// 【】空集合是括号 ####5、java.lang.String 字符串 /* 字符串的内容永不可变，常量，创建之后不能更改。（只能创建新字符串，改变变量地址值） 正是因为字符串不可改变，所以字符串是可以共享使用节省内存的。 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。 创建字符串常见方式： public String()，创建一个空白字符串，不含有任何内容。 public String(char[] array)，根据字符数组的内容，来创建对应的字符串。 public String(byte[] array), 根据字节数组的内容，来创建对应的字符串。 String str=”Hello”；//右边引号，直接创建 字符串常量池：程序中直接写上双引号字符串，就是在字符串常量池中。 */ public boolean equals（Object obj）; 字符串内容比较,只有参数是一个字符串并且内容相同才会true，否则false： 任何对象都能用Object接收、equals方法具有对称性，可以将两个字符串交换位置，但如果一个是常量一个是变量，推荐常量写在前面，避免空指针异常。 public boolean equalsIgnoreCase（Object obj）; 字符串内容比较,忽略英文大小写。 String 中与获取相关的常用方法： public int length(),获取字符串含有个数，字符串长度。 public String concat(String str),将当前字符串和参数字符串拼接返回新字符串。 public char charAt（int index），获取指定索引位置的单个字符（索引从0开始）。 public int indexOf（String str）,查找参数字符串在本字符串中首次出现的索引位置，如果没有返回-1。 String 中与截取相关的常用方法： public String substring(int index),截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin,int end),获取从begin开始，一直到end，左闭右开区间 String 中与转换相关的常用方法： public char[] toCharArray(),相当于拆分为字符数组作为返回值。 public byte[] getBytes()，获取当前字符串底层的字节数组。 public String replace(CharSequence oldString,CharSequence newString),将所有出现的老字符串代替成为新的字符串，返回处理后的新字符串。 String 中与转换分割的常用方法： public String[] split(String regex),按照参数的规则，将字符串切分为若干部分。 注：regex 为正则表达式，注意使用“\.”分割 ####6、静态static /* 一旦使用static关键字修饰变量，那么这样的内容不再属于对象自己，而是属于类的，所以凡是本类的对象，都可以共享同一份。 一旦使用static关键字修饰成员方法，那么该方法就成为静态方法，静态方法不属于对象，而属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用该方法。（静态方法强烈推荐使用类名称调用） 注意：静态只能访问静态，不能访问非静态。因为在内存中是先有静态内容，后有非静态内容（先人不知道后人，后人知道先人） ​ 静态方法中不能用this，this表示当前对象，通过谁调用的方法，谁就是当前对象。 静态代码块: 当第一次用到本类时，静态代码块执行唯一的一次。 静态内容总是优先于非静态的，所以静态代码块比构造方法先执行。 典型用途：用来一次性的对静态成员变量进行赋值。 */ ####7、java.util,Arrays,数组工具类 public static string toString(数组),将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3…]） public static void sort(数组)，按照默认顺序升序对数组的元素进行排序。 注意：如果是数值sort按照升序从小到大；如果是字符串sort按照字母升序；如果自定义类型，那么自定义的类需要有Comparable或者Comparator接口支持。 ####8、java.util.Math 数学工具类 public static double abs(double num),获取绝对值。 public static double ceil(double num),向上取整。 public static double floor(double num),向下取整。 public static Long round(double num),四舍五入。 Math.PI，近似圆周率。 ##继承与多态 ####1、继承 面向对象的三大特征：封装性、继承性、多态性。 继承是多态的前提，如果没有继承，就没有多态。 继承主要解决：共性抽取。 定义父类的格式： public class 父类名称 { 、、、 } 定义子类的格式： public class 子类名称 extends 父类名称 { 、、、 } 直接通过子类对象访问成员变量，等号左边是谁，就优先用谁，没有则向上找。 间接通过成员方法访问成员变量，该方法属于谁，就优先用谁，没有则向上找。 局部变量：直接写成员变量名； 本类的成员变量：this.成员变量名； 父类的成员变量：super.成员变量名； 在父子类的继承关系中，创建子类对象，访问成员方法规则:创建的对象是谁，就优先用谁，如果没有就向上找。 无论是成员方法还是成员变量，如果没有都是向上找父类，绝不会向下找之类的。 重写(Override) 概念：在继承关系当中，方法的名称一样，参数列表也一样。 重写(Override): 方法的名称一样，参数列表【也一样】，覆盖、重写。 重载(Overload): 方法的名称一样，参数列表【不一样】。 方法覆盖重写特点，创建的是子类对象，则优先用子类的方法。注意： 1、必须保证父子类之间方法的名称相同，参数列表也相同。 @Override，写在方法前面，用来检测是不是有效的正确覆盖重写。用来检测，只要满足要求，也是正确方法覆盖重写。 2、子类方法的返回值必须【小于等于】父类方法的返回值范围。（java.lang.Object类是所有类的公共最高父类） 3、子类方法的权限【大于等于】父类方法的权限修饰符。 扩展：public&gt;protected&gt;(default)&gt;private,(default)是什么都不写留空 private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。 protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问 父子类构造方法的访问特点：1、子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 2、子类构造可以通过super关键字来调用父类重载构造。 3、super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造。 super/this： 单继承： ####2、抽象类 抽象方法: 就是加上abstract关键字，然后去掉大括号，直接分号结束。 public abstract void 抽象方法名(); 抽象内：抽象方法所在的类，必须是抽象类才行，在class 之前写上abstract即可。 public abstract class 抽象类名 { } 1.不能直接创建new 抽象类对象； 2.必须用一个子类来继承抽象父类； 3.子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号 public class 子类名 extends 抽象类名 { } 4.创建子类对象进行使用。 注意事项： 发红包案例：]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown写作]]></title>
    <url>%2F2020%2F01%2F01%2FMarkdown%E5%86%99%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[如何使用Markdown写作Markdown 是一种轻量级的「标记语言」，优点在于 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 并且具有以下特点： 自动生成目录代码块高亮引用展示表格插入图片插入强调显示列表显示自动URL链接 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 语法简明概述 分段 两个回车 换行 两个空格 + 回车 标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题 强调 文字 ， 文字 ， 文字 ， 文字 ， 文字 引用 &gt; 注意后面紧跟个空格 表格 - 和 | 分割行和列 ， : 控制对其方式 代码块 四个空格 开头或， 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105- 链接 [文字](链接地址)- 图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址- 列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格## 标题&apos;&apos;&apos;# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &lt;h1&gt; &lt;/h1&gt;## 标题输入 //二级标题 对应 &lt;h2&gt; &lt;/h2&gt;### 三级标题 //三级标题 对应 &lt;h3&gt; &lt;/h3&gt;#### 四级标题 //四级标题 对应 &lt;h4&gt; &lt;/h4&gt;##### 五级标题 //五级标题 对应 &lt;h5&gt; &lt;/h5&gt;###### 六级标题 //六级标题 对应 &lt;h6&gt; &lt;/h6&gt;####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）&apos;&apos;&apos;这里不做展示了，影响目录的展示。## 内容强调### 加粗、斜体&apos;&apos;&apos;字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示&apos;&apos;&apos;字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示### 删除线&apos;&apos;&apos;这样来 ~~删除一段文本~~&apos;&apos;&apos;### 高亮使用&lt;code&gt;\`&lt;/code&gt;来强调字符 //想打出 ` (反引号)需要转义的，加&lt;code&gt;&lt;/code&gt;标签强调比如`突出背景色`来显示强调效果### 引用显示引用过程中任然支持Markdown语法！标准使用&apos;&apos;&apos;&gt; 每行开始都使用 &apos;&gt;&apos;；&gt; 引用**开始**；&gt; 引用**换行**；&gt; 引用**结束**。&gt; 还在引用中！`两个回车`结束引用！&apos;&apos;&apos;&apos;&apos;&apos;&gt; 仅第一行加应用；引用**开始**；引用**换行**；引用**结束**；&apos;&apos;&apos;两个回车结束引用,不在引用范围内了！嵌套使用&gt; 动物&gt;&gt; 水生动物&gt;&gt; 陆生动物&gt;&gt;&gt; 猴子&gt;&gt;&gt; 人&gt;&gt;&gt;&gt; 程序猿&gt;&gt;&gt;&gt; 攻城狮&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记&gt;&gt; 两栖类动物&gt;&gt;&gt; 大鳄鱼唐老鸭两个回车结束引用,不在引用范围内了！表格语法：列1 | 列2 | 列3 ----- | --- | ---- 第1行 | 12 | 13 第2行 | 22 | 23 第3行 | 32 | 33 可以使用冒号来定义对齐方式：| 左对齐 | 右对齐 | 居中 || :-------- | -------:| :--: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 |### 代码块代码块语法遵循标准 markdown 代码，使用 ``` 接上语言名称 开始 ， ``` 结束 例如：​```Python#!/usr/bin/env python# -*- coding: utf-8 -*-print &apos;Hello World! 链接： 首页 图片：]]></content>
      <tags>
        <tag>写作练习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F03%2FJAVA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[title: JAVA面试题date: 2019-06-03 18:33:17tags: Java Web基础面试题整理1、什么是Servlet？ 可以从两个方面去看Servlet： ​ a、API：有一个接口servlet，它是servlet规范中定义的用来处理客户端请求的程序需要实现的顶级接口。 ​ b、组件：服务器端用来处理客户端请求的组件，需要在web.xml文件中进行配置。 2、Servlet的生命周期，并说出Servlet和CGI的区别？ ​ servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。 ​ 这个生存期由javax.servlet.servlet接口中的init、service、destroy方法表达。 ​ web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现根据请求的不同调用不同的do**()方法。结束服务，web容器调用servlet的destroy()方法。 区别：​ Servlet处于服务器进程中，它通过多线程运行service()方法，一个实例可以服务于多个请求，并且实例一般不会被销毁；而CGI对每个请求都产生一个新的进程，服务完成后就销毁，所有效率低于Servlet 3、Servlet接口中有哪些方法？ Servlet接口定义了5个方法： void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destory() java.lang.String getServletInfo() ServletConfig getServletConfig() 4、get和post请求的区别？ a、get是用来从服务器上获取数据，而post是用来向服务器传递数据； b、get将表单中数据按照variable=value的形式，添加到action所指向的URL后面，并且两者用”？”连接，变量之间用”&amp;”连接；而post是将表单中的数据放在form的数据体中，按照变量与值对应的方式，传递到action所指定的URL。 c、get是不安全的，因为在传输过程中，数据是被放在请求的URL中;而post的所有操作对用户来说都是不可见的。 d、get传输的数据量小，这主要应为受url长度限制;而post可以传输大量的数据，所有上传文件只能用post提交。 e、get限制form表单的数据集必须为ASCII字符；而post支持整个IS01 0646字符集。 f、get是form表单的默认方法。 5、什么情况下调用doGet()和doPost()？ 默认情况是调用doGet()方法，JSP页面中的Form表单的method属性设置为post的时候，调用的为doPost()方法；为get的时候，调用deGet()方法。 6、转发（Forward）和重定向（Redirect）的区别？ 转发是服务器行为，重定向是客户端行为。 转发（Forword） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。 request.getRequestDispatcher(“login_success.jsp”).forward(request, response); 重定向（Redirect） 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 从地址栏显示来说 forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。redirect是服务端根据逻辑，发送一个状态码,告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL。 从数据共享来说 forward：转发页面和转发到的页面可以共享request里面的数据.redirect：不能共享数据. 从运用地方来说 forward：一般用于用户登陆的时候,根据角色转发到相应的模块.redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward：高.redirect：低. 7、自动刷新（Refresh） 自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如： Response.setHeader(“Refresh”,”1000;URL=http://localhost:8080/servlet/example.htm&quot;); 其中1000为时间，单位为毫秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现没过一秒自动刷新本页面一次） 8、Servlet与线程安全 Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。 9、JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？ JSP是Servlet的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是”类Servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是java和HTML可以组合成一个扩展名为.jsp的文件。JSP偏重于视图，Servlet偏重于业务逻辑。 10、JSP工作原理： JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。 工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。 由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。 开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。 11、Request对象的主要方法有哪些？ setAttribute(String name,Object)：设置名字为name的request 的参数值 getAttribute(String name)：返回由name指定的属性值 getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 getHeader(String name) ：获得HTTP协议定义的文件头信息 getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 getInputStream() ：返回请求的输入流，用于获得请求中的数据 getMethod() ：获得客户端向服务器端传送数据的方法 getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 getParameterValues(String name)：获得有name指定的参数的所有值 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 getQueryString() ：获得查询字符串 getRequestURI() ：获取发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的 IP 地址 getRemoteHost() ：获取客户端的名字 getSession([Boolean create]) ：返回和请求相关 Session getServerName() ：获取服务器的名字 getServletPath()：获取客户端所请求的脚本文件的路径 getServerPort()：获取服务器的端口号 removeAttribute(String name)：删除请求中的一个属性 12、request.getAttribute()和 request.getParameter()有何区别？ a、request.getParameter()获取的类型是String；request.getAttribute()获取的类型是Object。 b、request.getPrameter()获取的是POST/GET传递的参数值和URL中的参数；request.getAttribute()获取的是对象容器中的数据值/对象。 c、request.setAttribute()和request.getAttribute()可以发送、接收对象；request.getParamter()只能接收字符串，官方不开放request.setParamter()（也就是没有这个方法）。 ​ setAttribute()和getAttribute()的传参原理： setAttribute()是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另外一个页面时，应用服务器会把这块内存拷贝到另一个页面所对应的那块内存中。这个就可以通过getAttribute()获取到相应的参数值或者对象。 13、JSP中动态include和静态include的区别？ a、静态include：语法：&lt;%@ include file=”文件名” %&gt;，相当于复制，编辑时将对应的文件包含进来，当内容变化时，不会再一次对其编译，不易维护。 ​ b、动态include：语法：&lt;jsp:include page=”文件名”&gt;,能够自动检查被包含文件，当客户端对JSP文件进行请求时，会重新将对应的文件包含进来，进行实时的更新。 14、JSP有哪些内置对象？作用分别是什么？ JSP一共有9个内置对象： request：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest response:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse session:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession out：负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter application:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext config:表示ServletConfig，对应类型：javax.servlet.servletconfig exception:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception pagecontext:表示这个JSP页面上下文，对应类型：javax.servlet.jsp.pagecontext page:表示当前JSP页面本身。 15、JSP有哪些动作？作用分别是什么？ JSP一共有以下6中基本动作： JSP：include （当页面被请求的时候引入一个文件） JSP：forward （将请求转到另一个页面） JSP：useBean （获得JavaBean的一个实例） JSP：setProperty （设置JavaBean的属性） JSP：getProperty （获得JavaBean的属性） JSP：plugin （根据浏览器类型为Java插件生成object或者embed两种标记） 16、JSP常用指令有哪些？ page、include、taglib a、page指令：定义页面的一些属性。 常用属性： contentType=”text/html;charset=utf-8”; 向浏览器端输出数据的编码 pageEncoding=”utf-8”; JSP编译成java文件时所用的编码 session=”true” 是否自动创建session b、include指令：引入一个静态的JSP页面 c、taglib指令：引入一个标签库 17、讲解JSP中的四种作用域 JSP中的四种作用域包括page、request、session和application，具体来说： a、page是代表一个页面相关的对象和属性。一个页面由一个编译好的java servlet类（可以带有include指令，但不可以带有include动作）表示。这既包括servlet又包括编译成servlet的jsp页面。 ​ b、request是代表与web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个web组件（由于forware指令和include动作的关系） ​ c、session是代表与用于某个web客户机的一个用户体验相关的对象和属性。一个web回话也可以经常跨域多个客户机请求。 ​ d、application是代表与整个web应用程序相关的对象和属性。这实质上是跨域整个web应用程序，包括多个页面、请求和回话的一个全局作用域。 18、如何实现JSP或Servlet的单线程模式？ 在JSP中使用page指令进行设置，具体代码如下： &lt;%@page isThreadSafe=”false”%&gt; 对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。 说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。 19、JSP乱码如何解决？ a、JSP页面乱码：&lt;%@page contentType=”text/html;charset=utf-8” %&gt; ​ b、表单提交时出现乱码：request.setCharacterEncoding(“utf-8”); ​ c、数据库出现乱码：jdbc:mysql://localhost:3306:/user?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8; ​ 其实我一般的处理的方法就是配置一个过滤器对每个JSP页面进行字符集处理。 20、实现会话跟踪的技术有哪些？ 使用Cookie 向客户端发送Cookie Cookie c =new Cookie(“name”,”value”); //创建Cookiec.setMaxAge(606024); //设置最大时效，此处设置的最大时效为一天response.addCookie(c); //把Cookie放入到HTTP响应中 从客户端读取Cookie String name =”name”;Cookie[]cookies =request.getCookies();if(cookies !=null){ for(int i= 0;i&lt;cookies.length;i++){ Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); }} 优点: 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value 缺点: 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。 URL 重写 在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 优点： 在Cookie被禁用的时候依然可以使用 缺点： 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。 隐藏的表单域 优点： Cookie被禁时可以使用 缺点： 所有页面必须是表单提交之后的结果。 HttpSession 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。 21、Cookie和Session的的区别？ 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 22、什么是Tomcat？ Tomcat是一种web服务器，java编写的web项目可以部署在上面，用户在客户端请求时，都是将请求发到Tomcat上，Tomcat在将请求发到对应的项目上。 23、 详细描述MVC 基于java的web应用系统采用MVC设计模型，即用Model（模型）、View（视图）和Controller（控制）分离设计，这是目前web应用服务系统的主流设置方向。 ​ Model：处理业务逻辑的模块。 ​ View：负责页面显示，显示Model的处理结果给用户，主要实现数据到页面的转换过程。 ​ Controller：负责每个请求的分发，把Form数据传递给Model进行处理，处理完成后，把处理结果返回给相应的View显示给用户。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
